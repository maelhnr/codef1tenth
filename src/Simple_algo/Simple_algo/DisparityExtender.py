#!/usr/bin/env python

import math
import numpy as np
import rclpy
from rclpy.node import Node
import threading
import time
from sensor_msgs.msg import LaserScan
from ackermann_msgs.msg import AckermannDriveStamped


'''
Code inspired by the post https://www.nathanotterness.com/2019/04/the-disparity-extender-algorithm-and.html  -->  Disparity extender strategy
'''

# Topics used 
DRIVE_TOPIC = '/drive'
SCAN_TOPIC = '/scan'


class DisparityExtenderRace(Node):
    def __init__(self):
        super().__init__('disparity_extender')

        # Paramètres
        self.declare_parameters(
            namespace='',
            parameters=[
                ('min_speed', 0.8),
                ('max_speed', 1.0),
                ('absolute_max_speed', 1.1),
                ('min_distance', 0.35),
                ('max_distance', 3.0),
                ('no_obstacles_distance', 6.0)
            ]
        )

        # This is actually "half" of the car width, plus some tolerance.
        # Controls the amount disparities are extended by.
        self.car_width = 0.5 # 0.5
        # This is the difference between two successive LIDAR scan points that
        # can be considered a "disparity". (As a note, at 7m there should be
        # ~0.04m between scan points.)
        self.disparity_threshold = 0.2 
        # This is the arc width of the full LIDAR scan data, in degrees
        self.scan_width = 270.0
        # This is the radius to the left or right of the car that must be clear
        # when the car is attempting to turn left or right.
        self.turn_clearance = 0.3 
        # This is the maximum steering angle of the car, in degrees.
        self.max_turn_angle = 24.0 # 34.0
        # self.steering_factor = self.params[0] # scalar to steering angle output
        self.min_speed = self.get_parameter('min_speed').get_parameter_value().double_value
        self.max_speed = self.get_parameter('max_speed').get_parameter_value().double_value
        self.absolute_max_speed = self.get_parameter('absolute_max_speed').get_parameter_value().double_value
        # The forward distance at which the car will go its minimum speed.
        # If there's not enough clearance in front of the car it will stop.
        self.min_distance = self.get_parameter('min_distance').get_parameter_value().double_value
        # The forward distance over which the car will go its maximum speed.
        # Any distance between this and the minimum scales the speed linearly.
        self.max_distance = self.get_parameter('max_distance').get_parameter_value().double_value
        # The forward distance over which the car will go its *absolute
        # maximum* speed. This distance indicates there are no obstacles in
        # the near path of the car. Distance between this and the max_distance
        # scales the speed linearly.
        self.no_obstacles_distance = self.get_parameter('no_obstacles_distance').get_parameter_value().double_value
        # These allow us to adjust the angle of points to consider based on how
        # the wheels are oriented.
        self.min_considered_angle = -89.0 # -89.0
        self.max_considered_angle = 89.0 # 89.0
        # We'll use this lock to essentially drop LIDAR packets if we're still
        # processing an older one.
        self.lock = threading.Lock()
        self.should_stop = False
        self.total_packets = 0
        self.dropped_packets = 0
        # This is just a field that will hold the LIDAR distances.
        self.lidar_distances = None
        # This contains the LIDAR distances, but only "safe" reachable
        # distances, generated by extending disparities.
        self.masked_disparities = None
        # If we're constraining turns to be in the direction of a disparity,
        # then use this array to find indices of possible directions to move.
        self.possible_disparity_indices = None
        # This field will hold the number of LIDAR samples per degree.
        # Initialized when we first get some LIDAR scan data.
        self.samples_per_degree = 0
        
        self.create_subscription(LaserScan, SCAN_TOPIC, self.lidar_callback, 10)
        self.drive_pub = self.create_publisher(AckermannDriveStamped, DRIVE_TOPIC, 10)
        print(self.max_speed)
        print('abs', self.absolute_max_speed)
        return


    def run(self):
        """Pas utilisé par cette version avec ROS2
        """
        start_time = time.time()
        
        self.should_stop = True
        # Try, with a timeout, to acquire the lock and block the other threads
        got_lock = False
        for i in range(10):
            got_lock = self.lock.acquire(False)
            if got_lock:
                break
            time.sleep(0.05)
        duration = time.time() - start_time
        self.pub_drive_param.publish(0, 0)
        self.pub_drive_param.unregister()
        drop_rate = float(self.dropped_packets) / float(self.total_packets)
        if got_lock:
            self.lock.release()
        return


    def find_disparities(self):
        """Scans each pair of subsequent values, and returns an array of indices
        where the difference between the two values is larger than the given
        threshold. The returned array contains only the index of the first value
        in pairs beyond the threshold 

        Returns:
            array : array containing the indexes of threshold disparities 
        """
        to_return = []
        values = self.lidar_distances
        for i in range(len(values) - 1):
            if abs(values[i] - values[i + 1]) >= self.disparity_threshold:
                to_return.append(i)
        return to_return


    def half_car_samples_at_distance(self, distance):
        """Returns the number of points in the LIDAR scan that will cover half of
        the width of the car along an arc at the given distance

        Args:
            distance (_type_): distance la plus proche de la disparité

        Returns:
            int: le nombre de point lidar pour la largeur de la voiture
        """
        # This isn't exact, because it's really calculated based on the arc length
        # when it should be calculated based on the straight-line distance.
        # However, for simplicty we can just compensate for it by inflating the
        # "car width" slightly
        distance_between_samples = math.pi * distance / (180.0 *
            self.samples_per_degree)
        return int(math.ceil(self.car_width / distance_between_samples))


    def extend_disparities(self):
        """For each disparity in the list of distances, extends the nearest
        value by the car width in whichever direction covers up the more-
        distant points. Puts the resulting values in self.masked_disparities
        
        """
        values = self.lidar_distances
        masked_disparities = np.copy(values)
        disparities = self.find_disparities()
        # Keep a list of disparity end points corresponding to safe driving
        # angles directly past a disparity. We will find the longest of these
        # constrained distances in situations where we need to turn towards a
        # disparity
        self.possible_disparity_indices = []
        print("Got %d disparities." % (len(disparities)))
        for d in disparities:
            a = values[d]
            b = values[d + 1]
            # If extend_positive is true, then extend the nearer value to
            # higher indices, otherwise extend it to lower indices
            nearer_value = a
            nearer_index = d
            extend_positive = True
            if b < a:
                extend_positive = False
                nearer_value = b
                nearer_index = d + 1
            samples_to_extend = self.half_car_samples_at_distance(nearer_value)
            current_index = nearer_index
            for i in range(samples_to_extend):
                # Stop trying to "extend" the disparity point if we reach the
                # end of the array
                if current_index < 0:
                    current_index = 0
                    break
                if current_index >= len(masked_disparities):
                    current_index = len(masked_disparities) - 1
                    break
                # Don't overwrite values if we've already found a nearer point
                if masked_disparities[current_index] > nearer_value:
                    masked_disparities[current_index] = nearer_value
                # Finally, move left or right depending on the direction of the
                # disparity
                if extend_positive:
                    current_index += 1
                else:
                    current_index -= 1
            self.possible_disparity_indices.append(current_index)
        self.masked_disparities = masked_disparities
        return


    def angle_from_index(self, i):
        """ Returns the angle, in degrees, corresponding to index i in the
        LIDAR samples 
        Args : 
        i(int) : the index in the LIDAR samples
        Returns :
        the angles in degrees corresponding to the index"""
        min_angle = -(self.scan_width / 2.0)
        return min_angle + (float(i) / self.samples_per_degree)


    def index_from_angle(self, i):
        ''' Gets the index for a given angle ??
        Args: 
        i(int) : the index in the LIDAR samples
        Returns :
        the angles in degrees corresponding to the index"'''
        center_index = self.scan_width * (self.samples_per_degree / 2)
        return center_index + int(i * float(self.samples_per_degree))


    def find_widest_disparity_index(self):
        """ Returns the index of the distance corresponding to the "widest"
        disparity that we can safely target """
        masked_disparities = self.masked_disparities
        # Keep this at 0.1 so that we won't identify noise as a disparity
        max_disparity = 0.1
        max_disparity_index = None
        for d in self.possible_disparity_indices:
            # Ignore disparities that are behind the car
            angle = self.angle_from_index(d)
            if (angle < self.min_considered_angle) or (angle >
                self.max_considered_angle):
                continue
            angle = d * self.samples_per_degree
            distance = masked_disparities[d]
            prev = distance
            after = distance
            # The disparity must have been extended from one of the two
            # directions, so we can calculate the distance of the disparity by
            # checking the distance between the points on either side of the
            # index (note that something on the endpoint won't matter here
            # either. The inequalities are just for bounds checking, if either
            # one is outside the array, then we already know the disparity was
            # extended from a different direction
            if (d - 1) > 0:
                prev = masked_disparities[d - 1]
            if (d + 1) < len(masked_disparities):
                after = masked_disparities[d + 1]
            difference = abs(prev - after)
            if difference > max_disparity:
                max_disparity = difference
                max_disparity_index = d
        return max_disparity_index


    def find_new_angle(self):
        """ Returns the angle of the farthest possible distance that can be reached
        in a direct line without bumping into edges. Returns the distance in meters
        and the angle in degrees """
        self.extend_disparities()
        limited_values = self.masked_disparities
        max_distance = -1.0e10
        angle = 0.0
        # Constrain the arc of possible angles we consider.
        min_sample_index = int(self.index_from_angle(self.min_considered_angle))
        max_sample_index = int(self.index_from_angle(self.max_considered_angle))
        limited_values = limited_values[min_sample_index:max_sample_index]
        for i in range(len(limited_values)):
            distance = limited_values[i]
            if distance > max_distance:
                angle = self.min_considered_angle + float(i) / self.samples_per_degree
                max_distance = distance
        return distance, angle


    def scale_speed_linearly(self, speed_low, speed_high, distance, distance_low, distance_high):
        """Scales the speed linearly in [speed_low, speed_high] based on the
        distance value, relative to the range [distance_low, distance_high] 
        Args:
            speed_low (_type_): minimal speed
            speed_high (_type_): maximal speed
            distance (_type_): the distance to the point where you want to go 
            distance_low (_type_): minimum range
            distance_high (_type_): maximum range           
        Returns:
            speed : the speed scaled
        """
        distance_range = distance_high - distance_low
        ratio = (distance - distance_low) / distance_range
        speed_range = speed_high - speed_low
        return speed_low + (speed_range * ratio)


    def duty_cycle_from_distance(self, distance):
        """Takes a forward distance and returns a duty cycle value to set the
        car's velocity. Fairly unprincipled, basically just scales the speed
        directly based on distance, and stops if the car is blocked 

        Args:
            distance (_type_): the distance to the point where you want to go

        Returns:
            speed: the speed scaled based on the distance
        """
        if distance <= self.min_distance:
            speed = self.min_speed
        elif distance >= self.no_obstacles_distance:
            speed = self.absolute_max_speed
        elif distance >= self.max_distance and distance < self.no_obstacles_distance:
            speed = self.scale_speed_linearly(self.max_speed, self.absolute_max_speed, distance, self.max_distance, self.no_obstacles_distance)
        elif distance > self.min_distance and distance < self.max_distance:
            speed = self.scale_speed_linearly(self.min_speed, self.max_speed, distance, self.min_distance, self.max_distance)
        return speed


    def adjust_angle_for_car_side(self, target_angle):
        """ Takes the target steering angle, the distances from the LIDAR, and the
        angle covered by the LIDAR distances. Basically, this function attempts to
        keep the car from cutting corners too close to the wall. In short, it will
        make the car go straight if it's currently turning right and about to hit
        the right side of the car, or turning left or about to hit the left side 
        of the car 
        
        Returns :
        target_angle : angle to the point where you want to go : 0 if in the backward scan
        """
        scan_width = self.scan_width
        car_tolerance = self.turn_clearance
        distances = self.lidar_distances
        turning_left = target_angle > 0.0
        # Get the portion of the LIDAR samples facing sideways and backwards on
        # the side of the car in the direction of the turn
        samples_per_degree = float(len(distances)) / scan_width
        number_of_back_degrees = (scan_width / 2.0) - 90.0
        needed_sample_count = int(number_of_back_degrees * samples_per_degree)
        side_samples = []
        if turning_left:
            side_samples = distances[len(distances) - needed_sample_count:]
        else:
            side_samples = distances[:needed_sample_count]
        # Finally, just make sure no point in the backwards scan is too close
        for v in side_samples:
            if v <= car_tolerance:
                return 0.0
        return target_angle


    def update_considered_angle(self, steering_angle):
        """update l'angle minimal et maximal

        Args:
            steering_angle (_type_): _description_
        """
        actual_angle = steering_angle
        if actual_angle < -self.max_turn_angle:
            actual_angle = -self.max_turn_angle
        if actual_angle > self.max_turn_angle:
            actual_angle = self.max_turn_angle
        self.min_considered_angle = -89.0
        self.max_considered_angle = 89.0
        if actual_angle > 0:
            self.min_considered_angle -= actual_angle
        if actual_angle < 0:
            self.max_considered_angle += actual_angle
        return


    def set_steering_angle2drive(self, angle, speed):
        """Take into account the limits of steering angle in the real car and apply the steering factor
        Args:
            angle : angle que l'on souhaiterait envoyer en commande
            speed : vitesse que l'on souhaiterait envoyer en commande

        Returns:
            angle : angle de manoeuvre corrigé
        """
        if abs(angle) > 1.0: #dans le cas ou l'angle est important
            if abs(angle) > self.max_turn_angle: #si trop grand on met l'angle maximal
                if angle > 0:
                    steering_angle = self.max_turn_angle 
                if angle < 0:
                    steering_angle = -self.max_turn_angle
            else:
                steering_angle = angle
        else: #si l'angle est trop faible il n'est pas possible de tourner donc on le considère comme nul
            steering_angle = 0.0
        return self.set_steering_factor(math.radians(steering_angle), speed)


    def set_steering_factor(self, steering_angle, speed):
        """Set the steering factor as a function the speed of the car in order to improve the high speed performances (stability),
         avoiding to turn too much at high speed 
        Args:
            steering_angle : angle de manoeuvre 
            speed : vitesse

        Returns:
            angle : angle de manoeuvre corrigé d'un facteur en fonction de la vitesse
        """
        # alpha = 2.0 # 2.0
        # beta = 1.0 # 1.0
        # gamma = 0.9 # 1.0
        # scalar = alpha/((1+beta*speed)**gamma)
        if speed >= 4.0:
            scalar = 0.4
        else:
            scalar = 0.7
        return steering_angle*scalar


    def controller(self, desired_speed, target_angle):
        """Control the car: speed and steering angle 
        Args:
            desired_speed : la valeur de la vitesse de commande 
            target_angle : la valeur de l'angle de manoeuvre de commande
        """
        drive_msg = AckermannDriveStamped()
        drive_msg.drive.speed = desired_speed    
        drive_msg.drive.steering_angle = self.set_steering_angle2drive(target_angle, desired_speed) 
        self.drive_pub.publish(drive_msg)
        return

    
    def lidar_callback(self, lidar_data):
        """This is asynchronously called every time we receive new LIDAR data

        Args:
            lidar_data : données Lidar reçues
        """
        print('****************************************************')
        self.total_packets += 1
        # If the lock is currently locked, then previous LIDAR data is still
        # being processed
        if not self.lock.acquire(False):
            self.dropped_packets += 1
            return
        if self.should_stop:
            return
        start_time = time.time()
        self.lidar_distances = lidar_data.ranges
        self.samples_per_degree = float(len(self.lidar_distances)) / self.scan_width
        target_distance, target_angle = self.find_new_angle()
        safe_distances = self.masked_disparities
        forward_distance = safe_distances[int(len(safe_distances)*0.5)]
        target_angle = self.adjust_angle_for_car_side(target_angle)
        desired_speed = self.duty_cycle_from_distance(forward_distance)
        self.update_considered_angle(target_angle)
        duration = time.time() - start_time
        self.lock.release()
        
        print("Forward distance", forward_distance)
        print("Velocity", desired_speed)
        print("Target distance", target_distance)
        print("Target angle", target_angle)
        print("Steering angle", self.set_steering_angle2drive(target_angle, desired_speed)*180/np.pi)
        self.controller(desired_speed, target_angle)
        return

def main(args=None):
    rclpy.init(args=args)
    controller = DisparityExtenderRace()
    rclpy.spin(controller)
    controller.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
